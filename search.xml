<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[Android开发的一些小经验]]></title>
    <url>%2F2018%2F08%2F25%2FAndroid%E5%BC%80%E5%8F%91%E4%B8%80%E4%BA%9B%E5%B0%8F%E7%BB%8F%E9%AA%8C%2F</url>
    <content type="text"><![CDATA[需求：知名网友叫我写一个Android推送的客户端服务器推送文字 消息，客户端用socket实现消息接受，并用状态栏提示消息。 要点1、socket（tcp）的使用2、主线程不能进行耗时操作 -网络操作不能写在主线程 -网络操作不能写在主线程 -网络操作不能写在主线程 （被坑过的我说三遍！当时比较傻X_X） 3、Handler的使用4、Notification的使用5、activity、service之间的通讯(Intent和广播)6、service维护长连接 服务器端功能比较简单，就是发送消息，直接贴代码复制粘贴编译运行123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101import java.util.Scanner;import java.io.BufferedReader;import java.io.BufferedWriter;import java.io.IOException;import java.io.InputStream;import java.io.InputStreamReader;import java.io.OutputStreamWriter;import java.net.ServerSocket;import java.net.InetAddress;import java.util.Date;import java.text.SimpleDateFormat;import java.net.Socket;public class MySocketServer &#123; private static final int SOCKET_PORT = 9998; private ServerSocket serverSocket = null; private boolean flag = true; private BufferedReader reader; private BufferedWriter writer; /** * @param args */ public static void main(String[] args) &#123; MySocketServer socketServer = new MySocketServer(); socketServer.initSocket(); &#125; private void initSocket() &#123; try &#123; InetAddress ad=InetAddress.getLocalHost(); System.out.println("本机计算名：" + ad.getHostName()); System.out.println("IP地址：" + ad.getHostAddress()); serverSocket = new ServerSocket( SOCKET_PORT); System. out.println( "服务已经启动，端口号:" + SOCKET_PORT); while ( flag) &#123; Socket clientSocket = serverSocket.accept(); System.out.println( "有客户端连接" ); SocketThread socketThread = new SocketThread(clientSocket); socketThread.start(); &#125; &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; finally &#123; try &#123; writer.close(); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; &#125; &#125; public class SocketThread extends Thread &#123; private Socket socket; Scanner sc = null; SimpleDateFormat sdf=new SimpleDateFormat("MM-dd HH:mm:ss");//转换格式 public SocketThread(Socket clientSocket) &#123; this. socket = clientSocket; &#125; @Override public void run() &#123; super.run(); InputStream inputStream; try &#123; //获取输入流 inputStream = socket.getInputStream(); //得到读取BufferedReader对象 reader = new BufferedReader( new InputStreamReader(inputStream,"utf-8" )); writer = new BufferedWriter( new OutputStreamWriter(socket.getOutputStream(),"utf-8" )); while ( flag) &#123; if (true) &#123; System. out.println( "发送消息："); sc = new Scanner(System.in); String str=sc.nextLine(); writer.write("# "+sdf.format(new Date()) +": " +str+"\n" );//发送时间和输入的信息 writer.flush(); &#125; &#125; &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; &#125; &#125; * * * 客户端首先 先实现socket的连接 这里采用tcp要求：输入服务器IP和端口（你想要写死也可以）点击按钮开启socket服务 实现步骤：1、新建一个activity（里面定义一个Button 两个editText）和一个MyService.java2、点击Button，传ip和端口给service并启动3、service生成线程进行socket连接4、接受消息，用Handle更新ui，Notifiction提示消息 新建一个activity，我这里名为SecondActivity,为什么这样取，后面就会知道了 SecondActivity：没在AndroidManifest.xml声明的记得声明 后面会贴出整个清单文件123456789101112131415161718192021222324252627282930313233343536373839404142434445464748import android.content.Intent;import android.os.Bundle;import android.support.v7.app.AppCompatActivity;import android.view.KeyEvent;import android.view.View;import android.widget.Button;import android.widget.CheckBox;import android.widget.EditText;public class SecondActivity extends AppCompatActivity &#123; private Button button; private EditText ssip, ssport; @Override protected void onCreate(final Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.start); //我这里对应的布局名为start ，这里就不贴布局文件了 button = (Button) findViewById(R.id.button2); ssip = (EditText) findViewById(R.id.editText3); ssport = (EditText) findViewById(R.id.editText2); //点击事件 button.setOnClickListener(new View.OnClickListener() &#123; @Override public void onClick(View view) &#123; //调用方法 openService()； &#125; &#125;); &#125;//封装开启service的方法public void openService() &#123; //通过Intent与service通讯并开启service Intent intent = new Intent(SecondActivity.this, MyService.class); intent.putExtra("ip", ssip.getText().toString()); //获取输入ip intent.putExtra("port", ssport.getText().toString()); //获取输入端口 startService(intent); &#125;&#125; * * * MyService：Service基本上分为两种形式：启动状态，即startService()和绑定状态，即bindService() 详细这里用的是启动状态记得在AndroidManifest.xml声明服务 给足权限123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189import android.app.Notification;import android.app.NotificationChannel;import android.app.NotificationManager;import android.app.PendingIntent;import android.app.Service;import android.content.Context;import android.content.Intent;import android.os.Handler;import android.os.IBinder;import android.os.Message;import android.support.annotation.Nullable;import android.support.v4.app.NotificationCompat;import android.util.Log;import android.widget.Toast;import java.io.BufferedReader;import java.io.BufferedWriter;import java.io.InputStreamReader;import java.io.OutputStreamWriter;import java.net.Socket;import static android.content.ContentValues.TAG;public class MyService extends Service &#123; private Socket clientSocket; private BufferedWriter mWriter; private BufferedReader mReader; boolean isReceivingMsgReady; private int Notification_ID = 1; final String CHANNEL_ID = "channel_id_1"; final String CHANNEL_NAME = "channel_name_1"; private String ssip, temp; private int ssport; private String sb, string; //使用handler更新ui public Handler mHandler = new Handler() &#123; @Override public void handleMessage(Message msg) &#123; super.handleMessage(msg); switch (msg.what) &#123; case 0: try &#123; sb = msg.obj.toString(); //接收数据 sendNotification(sb);//状态栏通知消息 &#125; catch (Exception e) &#123; &#125; break; case 1: Toast.makeText(getApplicationContext(), "已经连接服务器", Toast.LENGTH_SHORT).show(); break; case 2: Toast.makeText(getApplicationContext(), "服务器已断开", Toast.LENGTH_SHORT).show(); break; &#125; &#125; &#125;; @Nullable @Override //必须复写 public IBinder onBind(Intent intent) &#123; return null; &#125; //这里进行初始化 @Override public void onCreate() &#123; super.onCreate(); Log.d(TAG, "onCreate: ############"); &#125;//这里会传进一个intent @Override public int onStartCommand(Intent intent, int flags, int startId) &#123; Log.d(TAG, "onStartCommand: ############"); ssip = intent.getStringExtra("ip"); //获取SecondActivity传来的IP和端口 temp = intent.getStringExtra("port"); ssport = Integer.parseInt(temp); //String 转int if (!isReceivingMsgReady) //没有这个，你点一次按钮，就创建一个线程，浪费资源 initSocket(ssip, ssport); //调用方法 return super.onStartCommand(intent, flags, startId); &#125; @Override public void onDestroy() &#123; super.onDestroy(); stopSelf(); Log.d(TAG, "onDestroy: ############"); &#125;//socket连接 private void initSocket(final String ip, final int port) &#123; //来个线程 service中也是不能直接进行耗时操作的 new Thread(new Runnable() &#123; @Override public void run() &#123; try &#123; //在子线程中初始化Socket对象 clientSocket = new Socket(ip, port); //根据clientSocket.getInputStream得到BufferedReader对象，从而从输入流中获取数据 isReceivingMsgReady = true; mReader = new BufferedReader(new InputStreamReader(clientSocket.getInputStream(), "utf-8")); //根据clientSocket.getOutputStream得到BufferedWriter对象，从而从输出流中获取数据 mWriter = new BufferedWriter(new OutputStreamWriter(clientSocket.getOutputStream(), "utf-8")); clientSocket.sendUrgentData(0xFF); //心跳包，不知道是不是这样用。 这行可以不要 //判断socket有无断开，一个特别简陋的方法 if (!clientSocket.isOutputShutdown()) &#123; mHandler.sendEmptyMessage(1);//toast通知已连接 while (isReceivingMsgReady) &#123; if (mReader.ready()) &#123; string = mReader.readLine(); //读取数据，这里要了解readLine()的特性。 mHandler.obtainMessage(0, string).sendToTarget();//发送数据给handle，通知更新ui Notification_ID++;//修改id，确保不覆盖消息，一条消息对应一个notification &#125; Thread.sleep(200); &#125; mWriter.close(); mReader.close(); clientSocket.close(); &#125; else &#123; mHandler.sendEmptyMessage(2);toast通知 &#125; &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; &#125; &#125;).start(); &#125;//状态通知服务器消息 这里要注意api的版本，我使用的方法是较新的 private void sendNotification(String str) &#123; NotificationManager manager = (NotificationManager) getSystemService(Context.NOTIFICATION_SERVICE); if (android.os.Build.VERSION.SDK_INT &gt;= android.os.Build.VERSION_CODES.O) &#123; //只在Android O之上需要渠道 NotificationChannel notificationChannel = new NotificationChannel(CHANNEL_ID, CHANNEL_NAME, NotificationManager.IMPORTANCE_HIGH); //如果这里用IMPORTANCE_NOENE就需要在系统的设置里面开启渠道， //通知才能正常弹出 manager.createNotificationChannel(notificationChannel); &#125; builder.setSmallIcon(R.mipmap.ic_launcher) .setContentTitle("_(:3」∠❀)_")//通知标题 .setContentText(str)//通知内容 .setAutoCancel(true) .setDefaults(Notification.DEFAULT_ALL); manager.notify(Notification_ID, builder.build()); &#125;&#125; 至此，基本实现推送功能。下面是我纯粹为了锻炼开发能力而添加的功能没有兴趣的读者可跳过 优化添加功能要添加的功能：1、监听返回键，按两次退出应用2、新建一个activity来显示所有接收的消息（广播）3、记住ip和端口4、来个自己的应用启动页 * * * 🌑监听返回键，按两次退出应用这里要复写activity的onKeyDown方法想要哪个activity有此功能，就把下面代码复制在哪个activity 1234567891011121314151617@Overridepublic boolean onKeyDown(int keyCode, KeyEvent event) &#123; if (keyCode == KeyEvent.KEYCODE_BACK &amp;&amp; event.getRepeatCount() == 0) &#123; exit(); return true; &#125; return super.onKeyDown(keyCode, event);&#125;private void exit() &#123; if ((System.currentTimeMillis() - mExitTime) &gt; 2000) &#123; Toast.makeText(MainActivity.this, "再按一次退出应用", Toast.LENGTH_SHORT).show(); mExitTime = System.currentTimeMillis(); &#125; else &#123; //用户退出处理 finish(); &#125; * * * 🌒新建一个activity来显示所有接收的消息这里会实现1、textview的竖直滚动，自动最后一行2、获取本机ip（WiFi和GPRS）3、广播接收Myservice传来的信息（成员内部类） 下面都会封装成方法这里我命名为MainActivity（定义一个Button，两个TextView），对应布局为activity_main.xml显示消息的textview 在布局文件中添加以下属性： 12345678android:enabled="true"android:textIsSelectable="true"android:focusable="true"android:longClickable="true"android:scrollbarFadeDuration="2000"android:scrollbars="none"android:fadeScrollbars="false"android:maxLines="28" //行数自定义 MainActivity：记得声明123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152import android.content.BroadcastReceiver;import android.content.Context;import android.content.Intent;import android.content.IntentFilter;import android.net.ConnectivityManager;import android.net.NetworkInfo;import android.net.wifi.WifiInfo;import android.net.wifi.WifiManager;import android.support.v7.app.AppCompatActivity;import android.os.Bundle;import android.text.TextUtils;import android.view.KeyEvent;import android.view.View;import android.widget.Button;import android.widget.TextView;import android.widget.Toast;import java.net.Inet4Address;import java.net.InetAddress;import java.net.NetworkInterface;import java.util.Enumeration;public class MainActivity extends AppCompatActivity &#123; private Button button; private TextView textview, iptv; private StringBuffer sb = new StringBuffer(); private Intent MyserviceIntent; private String getMyservice; int scrollAmount; private long mExitTime; private String ip; protected void onCreate(final Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.activity_main); button = (Button) findViewById(R.id.button);//用来结束service，退出应用 textview = (TextView) findViewById(R.id.textview);//显示消息 iptv = (TextView) findViewById(R.id.iptextView); ConnectivityManager conMann = (ConnectivityManager) this.getSystemService(Context.CONNECTIVITY_SERVICE); NetworkInfo mobileNetworkInfo = conMann.getNetworkInfo(ConnectivityManager.TYPE_MOBILE); NetworkInfo wifiNetworkInfo = conMann.getNetworkInfo(ConnectivityManager.TYPE_WIFI); //实例化广播接受器并动态注册 final MsgReceiver msgReceiver = new MsgReceiver();//实例化就可接受广播 IntentFilter intentFilter = new IntentFilter(); intentFilter.addAction("com.daby.communication.RECEIVER"); registerReceiver(msgReceiver, intentFilter); //判断网络类型 并获取IP if (mobileNetworkInfo.isConnected()) &#123; ip = getLocalIpAddress(); iptv.setText(getString(R.string.ipname) + ip); &#125; else if (wifiNetworkInfo.isConnected()) &#123; iptv.setText(getString(R.string.ipname) + wifigetIP(ip)); &#125; //关闭服务 MyserviceIntent = new Intent(getApplication(), MyService.class); button.setOnClickListener(new View.OnClickListener() &#123; @Override public void onClick(View view) &#123; Toast.makeText(getApplication(),"已断开服务器连接",Toast.LENGTH_SHORT).show(); stopService(MyserviceIntent); finish(); System.exit(0); &#125; &#125;); &#125; //获取GPRS ip private String getLocalIpAddress() &#123; String ip = ""; try &#123; for (Enumeration&lt;NetworkInterface&gt; en = NetworkInterface.getNetworkInterfaces(); en.hasMoreElements(); ) &#123; NetworkInterface intf = en.nextElement(); for (Enumeration&lt;InetAddress&gt; enumIpAddr = intf.getInetAddresses(); enumIpAddr.hasMoreElements(); ) &#123; InetAddress inetAddress = enumIpAddr.nextElement(); if (!inetAddress.isLoopbackAddress() &amp;&amp; inetAddress instanceof Inet4Address) &#123; ip = inetAddress.getHostAddress().toString(); break; &#125; &#125; if (!TextUtils.isEmpty(ip)) break; &#125; &#125; catch (Exception e) &#123; ip = ""; &#125; return ip; &#125; //获取wifi ip private String wifigetIP(String ip) &#123; //获取WiFi服务 WifiManager wifiManager = (WifiManager) getApplicationContext().getSystemService(Context.WIFI_SERVICE); //判断WiFi是否开启 if (!wifiManager.isWifiEnabled()) &#123; wifiManager.setWifiEnabled(true); &#125; WifiInfo wifiInfo = wifiManager.getConnectionInfo(); int ipaddress = wifiInfo.getIpAddress(); ip = intTolp(ipaddress);//调用格式转换 return ip; &#125; //wifi ip格式转换 private String intTolp(int i) &#123; return (i &amp; 0xFF) + "." + ((i &gt;&gt; 8) &amp; 0xFF) + "." + ((i &gt;&gt; 16) &amp; 0xFF) + "." + (i &gt;&gt; 24 &amp; 0xFF); &#125; //定义成员内部类，接受来自Myservice的广播 class MsgReceiver extends BroadcastReceiver &#123; @Override public void onReceive(Context context, Intent intent) &#123; getMyservice = intent.getStringExtra("Tomian"); sb.append(getMyservice + "\n"); textview.setText(sb); //滚动显示 textview.post(new Runnable() &#123; @Override public void run() &#123; scrollAmount = textview.getLayout().getLineTop(textview.getLineCount()) - textview.getHeight(); if (scrollAmount &gt; 0) textview.scrollTo(0, scrollAmount); else textview.scrollTo(0, 0); &#125; &#125;); &#125; &#125; //监听返回键，按两次退出 //为了代码看起来不多，这里就简写了！！！ @Override public boolean onKeyDown(int keyCode, KeyEvent event) &#123;...&#125; private void exit() &#123;...&#125; &#125; * * * 在Myservice进行修改发送广播！！！上面有的未修改代码简写123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293import...public class MyService extends Service &#123; private Socket... public Handler mHandler = new Handler() &#123; @Override public void handleMessage(Message msg) &#123;...&#125;; &#125; private void sendNotification(String str) &#123; NotificationManager manager = (NotificationManager) getSystemService(Context.NOTIFICATION_SERVICE); if (android.os.Build.VERSION.SDK_INT &gt;= android.os.Build.VERSION_CODES.O) &#123;...&#125; //这里添加 点击状态栏消息跳转MainActivity的功能 Intent intent = new Intent(getApplication(), MainActivity.class); PendingIntent contentIntent = PendingIntent.getActivity(getApplication(), 0, intent, PendingIntent.FLAG_UPDATE_CURRENT);//这里需要了解第四个参数 NotificationCompat.Builder builder = new NotificationCompat.Builder(this, CHANNEL_ID); builder.setSmallIcon(R.mipmap.ic_launcher) .setContentTitle("_(:3」∠❀)_") .setContentText(str) .setAutoCancel(true) .setContentIntent(contentIntent)//添加设置Intent，跳转 .setDefaults(Notification.DEFAULT_ALL); manager.notify(Notification_ID, builder.build()); &#125; private void initSocket(final String ip, final int port) &#123; new Thread(new Runnable() &#123; @Override public void run() &#123; try &#123; //在子线程中初始化Socket对象 clientSocket = new Socket... if (!clientSocket.isOutputShutdown()) &#123; mHandler.sendEmptyMessage(1); while (isReceivingMsgReady) &#123; if (mReader.ready()) &#123; string = mReader.readLine(); //这里要了解readLine()的特性。 mHandler.obtainMessage(0, string).sendToTarget(); TomainIntent.putExtra("Tomian", string); Notification_ID++; sendBroadcast(TomainIntent);//添加发送广播 &#125; Thread.sleep(200); &#125; mWriter.close(); mReader.close(); clientSocket.close(); &#125; else &#123; mHandler.sendEmptyMessage(2); &#125; &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; &#125; &#125;).start(); &#125; @Nullable @Override public IBinder onBind(Intent intent) &#123;return null;&#125; @Override public void onCreate() &#123;...&#125; @Override public int onStartCommand(Intent intent, int flags, int startId) &#123;...&#125; @Override public void onDestroy() &#123;...&#125;&#125; * * * 🌓记住ip和端口修改SecondActivity添加CheckBox，用SharedPreferences保存ip和端口连接后跳转到MainActivity123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124import android.content.Intent;import android.content.SharedPreferences;import android.os.Bundle;import android.os.Handler;import android.os.Message;import android.preference.PreferenceManager;import android.support.v7.app.AppCompatActivity;import android.view.KeyEvent;import android.view.View;import android.widget.Button;import android.widget.CheckBox;import android.widget.EditText;import android.widget.Toast;public class SecondActivity extends AppCompatActivity &#123; private Button button; private CheckBox checkBox; private EditText ssip, ssport; private SharedPreferences sharedPreferences; private SharedPreferences.Editor editor; private Handler mHandler; private long mExitTime; @Override protected void onCreate(final Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.start); button = (Button) findViewById(R.id.button2); checkBox = (CheckBox) findViewById(R.id.checkbox); ssip = (EditText) findViewById(R.id.editText3); ssport = (EditText) findViewById(R.id.editText2); sharedPreferences = PreferenceManager.getDefaultSharedPreferences(this); boolean pang = sharedPreferences.getBoolean("remember_servic", false); mHandler = new Handler() &#123; @Override public void handleMessage(Message msg) &#123; super.handleMessage(msg); switch (msg.what) &#123; case 0: Toast.makeText(SecondActivity.this, "空哦", Toast.LENGTH_SHORT).show(); break; &#125; &#125; &#125;; if (pang)//第一次运行 pang=false &#123; ssip.setText(sharedPreferences.getString("ip", "")); //读取数据 ssport.setText(sharedPreferences.getString("port", ""));//读取数据 checkBox.setChecked(true); &#125; button.setOnClickListener(new View.OnClickListener() &#123; @Override public void onClick(View view) &#123; remb(); &#125; &#125;); &#125; public void openService() &#123; Intent intent = new Intent(SecondActivity.this, MyService.class); intent.putExtra("ip", ssip.getText().toString()); intent.putExtra("port", ssport.getText().toString()); startService(intent); &#125;//连接成功后开启MainActivity public void openActivity() &#123; Intent intent2 = new Intent(SecondActivity.this, MainActivity.class); startActivity(intent2); overridePendingTransition(R.anim.open_in, R.anim.open_out); &#125;//封装记住密码方法 private void remb() &#123; editor = sharedPreferences.edit(); String tempip = ssip.getText().toString(); String tempport = ssport.getText().toString(); //判断一下输入IP和端口是否为空 if (!tempip.isEmpty() &amp;&amp; !tempport.isEmpty()) &#123; if (checkBox.isChecked()) &#123; //存放数据 editor.putString("ip", tempip); editor.putString("port", tempport); editor.putBoolean("remember_service", true); &#125; else &#123; editor.clear();//所有信息全部进行清空 &#125; editor.apply();//apply是将修改数据原子提交到内存，而后异步真正提交到硬件磁盘 openService(); openActivity(); finish(); &#125; else &#123; mHandler.sendEmptyMessage(0); &#125; &#125; &#125; @Override public boolean onKeyDown(int keyCode, KeyEvent event) &#123;...&#125; private void exit() &#123;...&#125;&#125; * * * 🌕来个自己的应用启动页1、新建一个activity（名为FirstActivity）对应布局welcome.xml2、定义一个ImageView 添加自己喜欢的图片，可以直接铺满activity我这里添加一个小logo，并实现旋转动画 注意： FirstActivity继承的是AppCompatActivity，直接继承Activity后，ImageView添加图片不显示，且使用隐藏的状态栏和标题栏的方法也不一样 FirstActivity：记得声明12345678910111213141516171819202122232425262728293031323334353637383940414243444546import android.content.Intent;import android.os.Bundle;import android.os.Handler;import android.support.annotation.Nullable;import android.support.v7.app.AppCompatActivity;import android.view.WindowManager;import android.view.animation.Animation;import android.view.animation.AnimationUtils;import android.view.animation.LinearInterpolator;import android.widget.ImageView;public class FirstActivity extends AppCompatActivity &#123; @Override protected void onCreate(@Nullable Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); //隐藏状态栏和标题栏，注意要写在setContentView前面 getSupportActionBar().hide(); getWindow().setFlags(WindowManager.LayoutParams.FLAG_FULLSCREEN, WindowManager.LayoutParams.FLAG_FULLSCREEN); setContentView(R.layout.welcome); //实现动画, Animation rotate = AnimationUtils.loadAnimation(this, R.anim.rotate_anim);//这里需要添加动画文件（名为rotate_anim.xml），放在res/anim/ 目录下 LinearInterpolator lin = new LinearInterpolator(); rotate.setInterpolator(lin); ((ImageView)findViewById(R.id.imageView3)).setAnimation(rotate); ((ImageView)findViewById(R.id.imageView3)).startAnimation(rotate); Handler hd = new Handler(); hd.postDelayed(new splashhandler(), 1150);//开启SecondActivity，1150是延迟操作的时间，单位毫秒 &#125; class splashhandler implements Runnable &#123; public void run() &#123; startActivity(new Intent(getApplication(), SecondActivity.class)); overridePendingTransition(R.anim.open_in, R.anim.open_out);//这里添加activity开启的动画。同样在在res/anim/ 目录下 FirstActivity.this.finish(); &#125; &#125;&#125; * rotate_anim：12345678910111213141516&lt;?xml version="1.0" encoding="utf-8"?&gt;&lt;set xmlns:android="http://schemas.android.com/apk/res/android"&gt; &lt;rotate android:fromDegrees="0" android:interpolator="@android:anim/cycle_interpolator" android:pivotX="50%" android:pivotY="50%" android:toDegrees="359" //具体参数可自己查询 android:duration = "1500" android:repeatCount = "-1" android:visible = "true"&gt; &lt;/rotate&gt;&lt;/set&gt; * open_in：1234567&lt;?xml version="1.0" encoding="utf-8"?&gt;&lt;set xmlns:android="http://schemas.android.com/apk/res/android"&gt; &lt;translate android:fromYDelta="100%p" android:toYDelta="0" android:duration="@android:integer/config_mediumAnimTime" /&gt;&lt;/set&gt; * open_out：12345678&lt;?xml version="1.0" encoding="utf-8"?&gt;&lt;set xmlns:android="http://schemas.android.com/apk/res/android"&gt; &lt;translate android:fromYDelta="0" android:toYDelta="-100%p" android:duration="@android:integer/config_mediumAnimTime" /&gt;&lt;/set&gt;&lt;!-- android:duration是动画时间--&gt; * * * 总清单文件AndroidManifest.xml：123456789101112131415161718192021222324252627282930313233343536373839404142&lt;?xml version="1.0" encoding="utf-8"?&gt;&lt;manifest xmlns:android="http://schemas.android.com/apk/res/android" package="com.example.daby.handlerdemo"&gt; &lt;uses-permission android:name="android.permission.ACCESS_WIFI_STATE" /&gt; &lt;uses-permission android:name="android.permission.CHANGE_WIFI_STATE" /&gt; &lt;uses-permission android:name="android.permission.WAKE_LOCK" /&gt; &lt;uses-permission android:name="android.permission.CHANGE_NETWORK_STATE" /&gt; &lt;uses-permission android:name="android.permission.ACCESS_NETWORK_STATE" /&gt; &lt;uses-permission android:name="android.permission.INTERNET" /&gt; &lt;uses-permission android:name="android.permission.VIBRATE" /&gt; &lt;uses-permission android:name="android.permission.FLASHLIGHT" /&gt; &lt;application android:allowBackup="true" android:icon="@mipmap/ic_launcher" android:label="@string/app_name" android:roundIcon="@mipmap/ic_launcher_round" android:supportsRtl="true" android:theme="@style/AppTheme"&gt; &lt;activity android:name=".FirstActivity"&gt;//这里设置FirstActivity为首个activity &lt;intent-filter &gt; &lt;action android:name="android.intent.action.MAIN"/&gt; &lt;category android:name="android.intent.category.LAUNCHER"/&gt; &lt;/intent-filter&gt; &lt;/activity&gt; &lt;activity android:name=".MainActivity" android:launchMode="singleTask"&gt;&lt;/activity&gt; //singleTask 非常重要，MainActivity被放入后台后，返回不会生成新的activity，保证数据不被清掉 &lt;service android:name=".MyService" /&gt; //声明服务 &lt;activity android:name=".SecondActivity"&gt;&lt;/activity&gt; &lt;/application&gt;&lt;/manifest&gt; * * * ======The end======]]></content>
      <tags>
        <tag>Android</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[安静]]></title>
    <url>%2F2017%2F11%2F26%2F%E5%AE%89%E9%9D%99%2F</url>
    <content type="text"><![CDATA[]]></content>
  </entry>
  <entry>
    <title><![CDATA[Android启动过程]]></title>
    <url>%2F2017%2F09%2F23%2FAndroid%E5%90%AF%E5%8A%A8%E8%BF%87%E7%A8%8B%2F</url>
    <content type="text"><![CDATA[Android从Linux系统启动有4个步骤：粗略 ① init进程启动② Native服务启动③ System Server，Android服务启动④ Home启动 🖼Android框架架构图：🖼启动框架如图：]]></content>
      <tags>
        <tag>Android</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Markdown语法手册]]></title>
    <url>%2F2017%2F09%2F04%2FMarkdown%E8%AF%AD%E6%B3%95%E6%89%8B%E5%86%8C%2F</url>
    <content type="text"><![CDATA[学习 Md ing 持续更新 概述宗旨 Markdown 的目标是实现「易读易写」。 可读性，无论如何，都是最重要的。一份使用 Markdown 格式撰写的文件应该可以直接以纯文本发布，并且看起来不会像是由许多标签或是格式指令所构成。Markdown 语法受到一些既有 text-to-HTML 格式的影响，包括 Setext、atx、Textile、reStructuredText、Grutatext 和 EtText，而最大灵感来源其实是纯文本电子邮件的格式。 总之， Markdown 的语法全由一些符号所组成，这些符号经过精挑细选，其作用一目了然。比如：在文字两旁加上星号，看起来就像*强调*。Markdown 的列表看起来，嗯，就是列表。Markdown 的区块引用看起来就真的像是引用一段文字，就像你曾在电子邮件中见过的那样。 兼容 HTML Markdown 语法的目标是：成为一种适用于网络的书写语言。 Markdown 不是想要取代 HTML，甚至也没有要和它相近，它的语法种类很少，只对应 HTML 标记的一小部分。Markdown 的构想不是要使得 HTML 文档更容易书写。在我看来， HTML 已经很容易写了。Markdown 的理念是，能让文档更容易读、写和随意改。HTML 是一种发布的格式，Markdown 是一种书写的格式。就这样，Markdown 的格式语法只涵盖纯文本可以涵盖的范围。 不在 Markdown 涵盖范围之内的标签，都可以直接在文档里面用 HTML 撰写。不需要额外标注这是 HTML 或是 Markdown；只要直接加标签就可以了。 要制约的只有一些 HTML 区块元素――比如 &lt;div&gt;、&lt;table&gt;、&lt;pre&gt;、&lt;p&gt;等标签，必须在前后加上空行与其它内容区隔开，还要求它们的开始标签与结尾标签不能用制表符或空格来缩进。Markdown 的生成器有足够智能，不会在 HTML 区块标签外加上不必要的&lt;p&gt; 标签 例子如下，在 Markdown 文件里加上一段 HTML 表格： 123456789这是一个普通段落。&lt;table&gt; &lt;tr&gt; &lt;td&gt;Foo&lt;/td&gt; &lt;/tr&gt;&lt;/table&gt;这是另一个普通段落。 请注意，在 HTML 区块标签间的 Markdown 格式语法将不会被处理。比如，你在 HTML 区块内使用 Markdown 样式的强调会没有效果。 HTML 的区段（行内）标签如 &lt;span&gt;、&lt;cite&gt;、&lt;del&gt;可以在 Markdown 的段落、列表或是标题里随意使用。依照个人习惯，甚至可以不用 Markdown 格式，而直接采用 HTML 标签来格式化。举例说明：如果比较喜欢 HTML 的 &lt;a&gt; 或 &lt;img&gt;标签，可以直接使用这些标签，而不用 Markdown 提供的链接或是图像标签语法。 和处在 HTML 区块标签间不同，Markdown 语法在 HTML 区段标签间是有效的。 特殊字符自动转换在 HTML 文件中，有两个字符需要特殊处理： &lt; 和 &amp;。 &lt;符号用于起始标签，&amp;符号则用于标记 HTML 实体，如果你只是想要显示这些字符的原型，你必须要使用实体的形式，像是 &amp;lt; 和 &amp;amp;。 &amp; 字符尤其让网络文档编写者受折磨，如果你要打「AT&amp;T」 ，你必须要写成「AT&amp;amp;T」。而网址中的 &amp; 字符也要转换。比如你要链接到：http://images.google.com/images?num=30&amp;q=larry+bird你必须要把网址转换写为：http://images.google.com/images?num=30&amp;amp;q=larry+bird才能放到链接标签的 href 属性里。不用说也知道这很容易忽略，这也可能是 HTML 标准检验所检查到的错误中，数量最多的。 Markdown 让你可以自然地书写字符，需要转换的由它来处理好了。如果你使用的 &amp;字符是 HTML 字符实体的一部分，它会保留原状，否则它会被转换成&amp;amp;。 所以你如果要在文档中插入一个版权符号 ©，你可以这样写：&amp;copy;Markdown 会保留它不动。而若你写：AT&amp;TMarkdown 就会将它转为：AT&amp;amp;T类似的状况也会发生在 &lt;符号上，因为 Markdown 允许 兼容 HTML ，如果你是把&lt;符号作为 HTML 标签的定界符使用，那 Markdown 也不会对它做任何转换，但是如果你写：4 &lt; 5Markdown 将会把它转换为：4 &amp;lt; 5不过需要注意的是，code 范围内，不论是行内还是区块， &lt;和 &amp;两个符号都一定会被转换成 HTML 实体，这项特性让你可以很容易地用 Markdown 写 HTML code(和 HTML 相对而言， HTML 语法中，你要把所有的 &lt; 和&amp; 都转换为 HTML 实体，才能在 HTML 文件里面写出 HTML code。) 附：markdown语法说明 ，上概述引用于此 1.斜体和粗体ex：12345*我是斜体* 或 _我也是斜体_**我是粗体*****加粗斜体*****_我也是加粗斜体_**~~我是删除线~~ 效果：我是斜体 或 我也是斜体我是粗体加粗斜体我也是加粗斜体我是删除线 2.分级标题（无演示效果）ex①：1234我是一个一级标题============================我是一个二级标题-------------------------------------------------- ex②：123456# 一级标题## 二级标题### 三级标题#### 四级标题##### 五级标题###### 六级标题 注：#后一定要有空格 3.超链接 两种形式:行内式（常用）和参考式 👉行内式 ex：123 [链接文字](链接地址 "链接标题")我是[百度](http://www.baidu.com "百度")我是[谷歌](http://www.google.com "谷歌") 效果：我是百度我是谷歌注：链接地址与链接标题前有一个空格()中的””中可以为链接指定title属性，title属性可加可不加。 title属性的效果是鼠标悬停在链接上会出现指定的 title文字。这样的形式。。 👉参考式 ex：1234 我经常用的网站有[google][1],[知乎][2]和[百度] [1]:http://www.google.com "Google"[2]:http://www.zhihu.com "zhihu"[百度]:http://www.baidu.com "baidu" 效果： 我经常用的网站有google,知乎和百度 注：多用于学术论文上面或一个链接在文章中多处使用的情况 👉自动链接：12&lt;http://baidu.com&gt;&lt;http://google.com&gt; 效果：http://baidu.comhttp://google.com 4.图片两种形式:行内式和参考式 👉行内式 ex：1234格式： ![随意](图片地址 "title")注意中英文感叹号！！！![巨帅](http://easyread.ph.126.net/ADTAnjLqofbVyKZq6Xq-kg==/6597234693401450458.jpg "Bang") 效果： 👉参考式 ex：123456格式：![随意][标记][标记]:图片地址 "title"![酷][我是一个标记][我是一个标记]:http://img.mp.sohu.com/upload/20170514/c6b047056ff245f9aa7e0d958177a852.png "Bang" 效果： 注：Markdown还没有办法指定图片的宽高，如果你需要的话，你可以使用普通的 &lt;img&gt; 标签]]></content>
  </entry>
  <entry>
    <title><![CDATA[常用hexo命令]]></title>
    <url>%2F2017%2F09%2F04%2F%E5%B8%B8%E7%94%A8hexo%E5%91%BD%E4%BB%A4%2F</url>
    <content type="text"><![CDATA[常见命令1234567hexo new &quot;postName&quot; #新建文章hexo new page &quot;pageName&quot; #新建页面hexo generate #生成静态页面至public目录hexo server #开启预览访问端口（默认端口4000，&apos;ctrl + c&apos;关闭server）hexo deploy #部署到GitHubhexo help # 查看帮助hexo version #查看Hexo的版本 缩写1234hexo n == hexo newhexo g == hexo generatehexo s == hexo serverhexo d == hexo deploy 组合命令12hexo s -g #生成并本地预览hexo d -g #生成并上传]]></content>
  </entry>
</search>
